package database_test

import (
	"database/sql/driver"
	"testing"
	"tui/flightmarketplace/database"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jinzhu/gorm"
)

var (
	gormDB  *gorm.DB
	mocksql sqlmock.Sqlmock
	client  *database.PostgresClient
)

func setupMockPostgres(t *testing.T) {
	// mock sql.DB
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherEqual))
	if err != nil {
		t.Fatalf("error creating mock database: %v", err)
	}
	// open gorm db
	gdb, err := gorm.Open("postgres", db)
	if err != nil {
		t.Fatalf("error opening database connection: %v", err)
	}
	// initialize PostgresClient with mock db
	psqlTestClient := &database.PostgresClient{DB: gdb}

	gormDB = gdb   // Assign the *gorm.DB instance to the global variable
	mocksql = mock // Assign the sqlmock.Sqlmock instance to the global variable
	client = psqlTestClient
}

// teardown closes the mock database connection after each test
/* func teardown() {
	err := gormDB.Close()
	if err != nil {
		panic("error closing database connection: " + err.Error())
	}
} */

func TestPostgresClient_ConfigureTables(t *testing.T) {
	setupMockPostgres(t)

	// Add expectations for the database calls
	queryUser := `CREATE TABLE "users" ("id" uuid,"username" varchar(100) UNIQUE,"email" varchar(255) UNIQUE,"password" varchar(255),"role" varchar(50) , PRIMARY KEY ("id"))`
	queryFlight := `CREATE TABLE "flights" ("id" uuid,"origin" varchar(70),"destination" varchar(70),"departure_date_time" timestamp with time zone,"arrival_date_time" timestamp with time zone,"price" numeric,"available_seats" integer , PRIMARY KEY ("id"))`
	queryOrder := `CREATE TABLE "orders" ("id" uuid,"user_id" uuid,"flight_id" uuid,"booking_date" timestamp with time zone,"payment_status" varchar(50) , PRIMARY KEY ("id"))`
	createIndexOrderUserID := `CREATE INDEX idx_orders_user_id ON "orders"(user_id)`
	createIndexOrderFlightID := `CREATE INDEX idx_orders_flight_id ON "orders"(flight_id)`
	mocksql.ExpectExec(queryUser).WillReturnResult(sqlmock.NewResult(0, 0))
	mocksql.ExpectExec(queryFlight).WillReturnResult(sqlmock.NewResult(0, 0))
	mocksql.ExpectExec(queryOrder).WillReturnResult(sqlmock.NewResult(0, 0))
	mocksql.ExpectExec(createIndexOrderUserID).WillReturnResult(sqlmock.NewResult(0, 0))
	mocksql.ExpectExec(createIndexOrderFlightID).WillReturnResult(sqlmock.NewResult(0, 0))

	// Run the ConfigureTables function
	err := client.ConfigureTables()
	if err != nil {
		t.Fatalf("error configuring tables: %v", err)
	}

	// Ensure all expectations were met
	if err := mocksql.ExpectationsWereMet(); err != nil {
		t.Errorf("unfulfilled expectations: %s", err)
	}
}

// Other test functions ...

func TestMain(m *testing.M) {
	// Run the tests
	exitCode := m.Run()

	// Exit with the appropriate exit code
	if exitCode != 0 {
		panic("test failed with exit code: " + string(rune(exitCode)))
	}
}

type Any struct{}

// Match satisfies sqlmock.Argument interface
// Used to mock INSERT id generated by beforecreate... IT is not important the exact auto generated id
func (a Any) Match(v driver.Value) bool {
	return true
}
